# やりたいこと
1. 2次元の箱の中にたくさんの粒子を入れる。(箱は周期境界)
1. 毎ステップ粒子間の相互作用の計算を行って、そこで得た力を元に粒子を少しずつ動かす。
1. ある時間ごとの粒子座標を記録する。

# 仕様
## クラス
このコードには現在Box、Particlesの2つのクラスがある。

## Particles
particlesはN個のD次元ガラス粒子群を表現するクラスである。ホスト側、デバイス側それぞれに変数と関数がある。

### ホスト側
- float diam[N]: 半径群
- float x[D*N]: 座標群
- float v[D*N]: 速度群

- void makeParticles(Particles* p): (デバイス側も含め)粒子群を作る
- void killParticles(Particles* p):（デバイス側も含め)粒子群をFreeする。
- void initParticles(Particles* p, Box* box): (デバイス側も含め)粒子群を初期化する。

- void setvgzero2D(Particles* p): 粒子群の平均速度を0にする

#### デバイス側
- float diam_dev[]
- float x_dev[]
- flaot v_dev[]
- flaot force_dev[D*N]: 粒子群にかかる力で加速度に影響する。

- __global__ void vDvlp(Particles* p, float *v_dev, Box* box, float *force_dev): この時点での粒子群の速度を更新する。
- __global__ xDvlp(Particles* p, float *x_dev, Box* box, float *v_dev): この時点での粒子群の座標を更新する。

## Box
### システムの基本的な構成要素
#### ホスト側
- unsigned int(以降uint) id: この箱のIDを入れる(統計性を管理する)
- double dt: 時間刻み幅(初期条件を作るときは荒く、記録、解析するときは細かく取る)
- double t: 時間
- float T: 温度
- float L: 箱の辺の長さ
- Particles p: 粒子群

- float getNU(Box* box): 位置エネルギーを取得
- float getNK(Box* box): 運動エネルギー(実温度)を取得

- void makeBox(*Box box)
- void killBox(*Box box)
- void initBox(*Box box)

### 領域を分割するgridを作るための構成要素
#### ホスト側
- uint M: M^D個の領域に系を分割する
- uint EpM: 1つの領域に入る粒子数

- void makeInteractionPattern(Box* box): pattern_dev[]を作成する。

#### デバイス側
- uint pattern_dev[]: ある領域ついて計算完了したGPUが次に参照するべき領域を記している
- uint* needUpdate_dev: 領域の更新をすべきかのフラグ
- uint map_dev[M^D][EpM+1]: 領域の実体: [][0]には領域に実際に入っている粒子数が入っている
- float positionMemory_dev[]: 領域を更新したときの粒子配置を記録している。

### 相互作用計算に関する関数
#### デバイス側
- __global__ void culcInteraction(Box* box, float* force_dev, uint* map_dev, uint* pattern_dev, float* diam_dev, float* x_dev): 相互作用計算をする

### 時間発展に関する関数
#### ホスト側
void tEvo(Box* box): 粒子群の座標を更新する

#### 平衡化
void coolenBox(Box* box): 系を冷やす
void equilibrateBox(Box* box): 系を安定するまで放置

### 記録用の実体
#### ホスト側
- ofstream positionFile: 時間別の位置情報を記録用の実体
- ofstream logFile: logを取る

- void recordSys(Box* box): この時点でのデータを記録
- void getData(): 平衡化を経て記録するために時間をすすめる。